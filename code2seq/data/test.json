{"code": "public void setPortString(String port) { portString=port; }", "nl": "sets the server port number nb it accepts a string, and not an int"}
{"code": "public boolean canRedo() { return indexOfNextAdd < history.size(); }", "nl": "returns true if a redo is possible"}
{"code": "public Items withTotalResults(BigInteger value) { setTotalResults(value); return this; }", "nl": "sets the value of the totalresults property"}
{"code": "public BrowseNodeLookupRequest withResponseGroup(String... values) { for (String value: values) { getResponseGroup().add(value); } return this; }", "nl": "sets the value of the responsegroup property"}
{"code": "public Boolean isHasTripodMount() { return hasTripodMount; }", "nl": "gets the value of the hastripodmount property"}
{"code": "public String getSchema() { return fSchema; }", "nl": "returns a path to the xml schema of a extension point"}
{"code": "private void notifyReceivedResource(ResourceReceivedInfo info) { for(PastryProtocolListenerIfc listener : listeners) { listener.resourceReceived(info); } }", "nl": "informs the configured listener(s) that the resource described by the input  has been received by this node for local storage"}
{"code": "public float getDashPhase() { return dashPhase; }", "nl": "gets the dash phase of the basicstroke"}
{"code": "public void setColorFilter(int color, PorterDuff.Mode mode) { setColorFilter(new PorterDuffColorFilter(color, mode)); }", "nl": "specify a color and porterduff mode to be the colorfilter for this  drawable"}
{"code": "public void setReadTimeout(int timeout) { if (0 > timeout) { } this.readTimeout = timeout; }", "nl": "sets the timeout value in milliseconds for reading from the input stream"}
{"code": "public void testCompareAndSetInMultipleThreads() { final AtomicReference ai = new AtomicReference(one); Thread t = new Thread(new Runnable() { public void run() { while(!ai.compareAndSet(two, three)) Thread.yield(); }}); try { t.start(); assertTrue(ai.compareAndSet(one, two)); t.join(LONG_DELAY_MS); assertFalse(t.isAlive()); assertEquals(ai.get(), three); } catch(Exception e) { unexpectedException(); } }", "nl": "compareandset in one thread enables another waiting for value  to succeed"}
{"code": "public void testGetThreadFactory() { ThreadFactory tf = new SimpleThreadFactory(); ThreadPoolExecutor p = new ThreadPoolExecutor(1,2,LONG_DELAY_MS, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<Runnable>(10), tf, new NoOpREHandler()); assertSame(tf, p.getThreadFactory()); joinPool(p); }", "nl": "getthreadfactory returns factory in constructor if not set"}
{"code": "private void indexById() { if (sessionsById == null) { sessionsById = new HashMap<ByteArray, SSLSession>(); for (SSLSession session : sessions.values()) { sessionsById.put(new ByteArray(session.getId()), session); } } }", "nl": "ensures that the id-based index is initialized"}
{"code": "public void transferAllFields(String fromTable, String toTable) { this.mode = MODE_TRANSFER_ALL; this.tableLeft = fromTable; this.tableRight = toTable; start(); }", "nl": "set up tables from to"}
{"code": "public String getAbsolutePath() { return getLocation().toOSString(); }", "nl": "returns the absolute pathname string of this abstract pathname"}
{"code": "protected void optimize() { optimize(false); }", "nl": "calls the optimization in soft mode: free resources only if needed"}
{"code": "public boolean getChanged() { return changed; }", "nl": "checks if any changes have been made to the document since last save"}
{"code": "public void testByteArrayToString() throws Exception { String source=\"abcdefghijklmnopqrstuvwxyz\\u1234\\n\"; String result = Utilities.byteArrayToString(source.getBytes(\"UTF-8\")); assertEquals(\" 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70 abcdefghijklmnop\"+newLine+ \" 71 72 73 74 75 76 77 78 79 7a e1 88 b4 0a qrstuvwxyz....\"+newLine+newLine, result); }", "nl": "test of bytearraytostring method, of class orgoclcossrwutilities"}
{"code": "public void removeLastStmt() { final ListIterator iter = stmts.listIterator(stmts.size()); while (iter.hasPrevious()) { final Stmt s = (Stmt) iter.previous(); if (s instanceof LabelStmt) { continue; } iter.remove(); return; } }", "nl": "removes the last non-label statement from the statement list"}
{"code": "public void setConfirmButtonTooltipText(String text){ confirmButton.setToolTipText(text); }", "nl": "change the confirm button tooltip text (hook for i18n)"}
{"code": "public void setProjectViewController(ProjectViewController controller){ this.projectViewController = controller; }", "nl": "if attaching it to the projectdetailview"}
{"code": "public void testGetSetContextPrinting() { TTCCLayout layout = new TTCCLayout(); assertEquals(true, layout.getContextPrinting()); layout.setContextPrinting(false); assertEquals(false, layout.getContextPrinting()); layout.setContextPrinting(true); assertEquals(true, layout.getContextPrinting()); }", "nl": "tests getcontextprinting and setcontextprinting"}
{"code": "public MTComponent getCreatedSvgComponents(SVGDocument svgDoc){ ArrayList<MTComponent> components = new ArrayList<MTComponent>(); opacityStack.push(1.0f); traverseSVGDoc(svgDoc, components); opacityStack.pop(); MTComponent[] comps = (MTComponent[])components.toArray(new MTComponent[components.size()]); return comps[0]; }", "nl": "creates and returns components of the provided svg document for displaying"}
{"code": "public Cursor getInitialCursor() { return Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR); }", "nl": "by default all creation modes use crosshair_cursor"}
{"code": "public void setSchema(String s) throws SQLException { executeUpdate(\"SET search_path TO \"+s+\", public\"); schema=s; description=description.substring(0,description.lastIndexOf(' '))+\" \"+schema; }", "nl": "sets the default schema"}
{"code": "public boolean getMissingMerge () { return m_missing_merge; }", "nl": "get whether missing values are being distributed or not"}
{"code": "public double getToleranceParameter() { return m_smoTParameter; }", "nl": "get the value of t used with smo"}
{"code": "public String reportFrequencyTipText() { return \"Set how frequently reports are generated. Default is equal to \" +\"the number of generations meaning that a report will be printed for \" +\"initial and final generations. Setting the value to 5 will result in \" +\"a report being printed every 5 generations.\"; }", "nl": "returns the tip text for this property"}
{"code": "public String thresholdTipText() { return \"Repeat xval if stdev of mean exceeds this value.\"; }", "nl": "returns the tip text for this property"}
{"code": "public String toString() { StringBuffer temp = new StringBuffer(); temp.append(\"\\n FarthestFirst\\n==============\\n\"); temp.append(\"\\nCluster centroids:\\n\"); for (int i = 0; i < m_NumClusters; i++) { temp.append(\"\\nCluster \"+i+\"\\n\\t\"); for (int j = 0; j < m_ClusterCentroids.numAttributes(); j++) { if (m_ClusterCentroids.attribute(j).isNominal()) { temp.append(\" \"+m_ClusterCentroids.attribute(j). value((int)m_ClusterCentroids.instance(i).value(j))); } else { temp.append(\" \"+m_ClusterCentroids.instance(i).value(j)); } } } temp.append(\"\\n\\n\"); return temp.toString(); }", "nl": "return a string describing this clusterer"}
{"code": "private void setClassValue(int index, int classVal) throws Exception { if (m_trainingData == null) { throw new Exception(\"No training data set (BoundaryPanel)\"); } if (classVal < 0 || classVal > m_trainingData.classAttribute().numValues()) { throw new Exception(\"Class value out of range (BoundaryPanel)\"); } m_rgbClassValues[index] = classVal; }", "nl": "set a class value for a particular colour (rgb)"}
{"code": "public void setAnimated() { m_visualLabel.setIcon(m_animatedIcon); }", "nl": "set the animated version of the icon"}
{"code": "public void setDisplayConnectors(boolean dc) { m_displayConnectors = dc; repaint(); }", "nl": "turn onoff the connector points"}
{"code": "public void addRepaintNotify(Component c) { m_Repainters.addElement(c); }", "nl": "adds a component that will need to be repainted if the user changes the colour of a label"}
{"code": "public void setExperiment(Experiment exp) { m_Exp = exp; m_AddBut.setEnabled(true); m_List.setModel(m_Exp.getDatasets()); if (m_Exp.getDatasets().size() > 0) { m_DeleteBut.setEnabled(true); } }", "nl": "tells the panel to act on a new experiment"}
{"code": "public void setOptions(String[] options) throws Exception { String classifierString = Utils.getOption('B', options); if (classifierString.length() == 0) { throw new Exception(\"A classifier must be specified\" + \" with the -B option.\"); } String [] classifierSpec = Utils.splitOptions(classifierString); if (classifierSpec.length == 0) { throw new Exception(\"Invalid classifier specification string\"); } String classifierName = classifierSpec[0]; classifierSpec[0] = \"\"; System.out.println(\"Classifier name: \" + classifierName + \"\\nClassifier parameters: \" + weka.classifiers.sparse.IBkMetric.concatStringArray(classifierSpec)); setClassifier(Classifier.forName(classifierName, classifierSpec)); }", "nl": "parses a given list of options valid options are: -b classifierstring"}
{"code": "public void deleteAttributeAt(int position) { if ((position < 0) || (position >= m_Attributes.size())) { throw new IllegalArgumentException(\"Index out of range\"); } if (position == m_ClassIndex) { throw new IllegalArgumentException(\"Can't delete class attribute\"); } freshAttributeInfo(); if (m_ClassIndex > position) { m_ClassIndex--; } m_Attributes.removeElementAt(position); for (int i = position; i < m_Attributes.size(); i++) { Attribute current = (Attribute)m_Attributes.elementAt(i); current.setIndex(current.index() - 1); } for (int i = 0; i < numInstances(); i++) { instance(i).forceDeleteAttributeAt(position); } }", "nl": "deletes an attribute at the given position (0 to numattributes() - 1) a deep copy of the attribute information is performed before the attribute is deleted"}
{"code": "public String rawOutputTipText() { return \"Save raw output (useful for debugging). If set, then output is \" +\"sent to the destination specified by outputFile\"; }", "nl": "returns the tip text for this property"}
{"code": "public String numRulesTipText() { return \"Number of rules to find.\"; }", "nl": "returns the tip text for this property"}
{"code": "public void setAdvanceDataSetFirst(boolean newAdvanceDataSetFirst) { m_AdvanceDataSetFirst = newAdvanceDataSetFirst; }", "nl": "set the value of m_advancedatasetfirst"}
{"code": "private String testPrologComparisonString() { Attribute att = m_Dataset.attribute(m_AttIndex); if (att.isNumeric()) { return ((m_Not ? \">= \" : \"< \") + Utils.doubleToString(m_Split,3)); } else { if (att.numValues() != 2) return ((m_Not ? \"!= \" : \"= \") + att.value((int)m_Split)); else return (\"= \" + (m_Not ? att.value((int)m_Split == 0 ? 1 : 0) : att.value((int)m_Split))); } }", "nl": "gives a string representation of the test in prolog notation, starting from the comparison symbol"}
{"code": "public DoubleVector dividedBy ( DoubleVector v ) { return copy().dividedByEquals( v ); }", "nl": "divided by another doublevector element by element"}
{"code": "public int getClassIndex() { return m_ClassIndex + 1; }", "nl": "get the index (starting from 1) of the attribute used as the class"}
{"code": "public String classifierTipText() { return \"the desired base learner for the ensemble.\"; }", "nl": "returns the tip text for this property"}
{"code": "public double getRandomWidthFactor() { return m_RandomWidthFactor; }", "nl": "gets the multiplier when generating random codes will generate numclasses m_randomwidthfactor codes"}
{"code": "public double getAttributeMax(int index) throws Exception { if (m_Max == null) { throw new Exception(\"Maximum value for attribute not available!\"); } return m_Max[index]; }", "nl": "get an attributes maximum observed value"}
{"code": "public String graph() throws Exception { StringBuffer text = new StringBuffer(); text.append(\"digraph M5Tree {\\n\"); Rule temp = (Rule)m_ruleSet.elementAt(0); temp.m_topOfTree.graph(text); text.append(\"}\\n\"); return text.toString(); }", "nl": "return a dot style string describing the tree"}
{"code": "private int numParameters() { return m_numParameters; }", "nl": "get the number of parameters in the model at this node"}
{"code": "public void setTempDirPath(String tempDirPath) { m_tempDirPath = tempDirPath; }", "nl": "set the path for the temporary files"}
{"code": "public void printAllModels() { if (m_isLeaf) { System.out.println(m_nodeModel.toString()); } else { System.out.println(m_nodeModel.toString()); m_left.printAllModels(); m_right.printAllModels(); } }", "nl": "print all the linear models at the learf (debugging purposes)"}
{"code": "public void setAttributeName(String name) { String newName = name.trim(); if (newName.indexOf(' ') >= 0) { if (newName.indexOf('\\'') != 0) { newName = newName.replace('\\'',' '); } newName = '\\'' + newName + '\\''; } if (newName.equals(\"\")) { newName = \"unnamed\"; } m_Name = newName; }", "nl": "set the new attribute's name"}
{"code": "public Enumeration listOptions() { Vector result = new Vector(); result.addElement(new Option( \"\\tRandom number seed.\\n\" + \"\\t(default \" + m_SeedDefault + \")\", \"S\", 1, \"-S <num>\")); return result.elements(); }", "nl": "returns an enumeration describing the available options"}
{"code": "public String preserveInstancesOrderTipText() { return \"Preserve order of instances.\"; }", "nl": "returns the tip text for this property"}
{"code": "public String debugLevelTipText() { return \"The debug level to use.\"; }", "nl": "returns the tip text for this property"}
{"code": "public String getSearchString() { return m_SearchString; }", "nl": "returns the search string, can be null if no search string is set"}
{"code": "public void clearSearch() { getTable().setSearchString(\"\"); }", "nl": "clears the search, ie resets the found cells"}
{"code": "public void setSelected(boolean newValue) { m_Selected = newValue; }", "nl": "setter for the node selected state"}
{"code": "protected void validate() { if (!m_Validated) { initialize(); m_Validated = true; } }", "nl": "performs the initializations if necessary"}
{"code": "public Object clone() { TestInstances result; result = new TestInstances(); result.assign(this); return result; }", "nl": "creates a clone of the current object"}
